'use strict';

var MODULE_NAME = 'zent';

// Errors:
// import 'zent';
// import * as Zent from 'zent';
// import Zent from 'zent';
// require('zent');
//
//
// Ingore:
// import Button from 'zent/button';
// import Button from 'zent-button';
// require('zent-button')
module.exports = function (babel) {
  var t = babel.types;


  return {
    visitor: {
      CallExpression(path) {
        var node = path.node;

        // no require('zent') calls

        if (t.isIdentifier(node.callee, { name: 'require' }) && node.arguments && node.arguments.length === 1) {
          var source = node.arguments[0];
          if (t.isStringLiteral(source, { value: MODULE_NAME })) {
            throw path.buildCodeFrameError(`require('${MODULE_NAME}') is not allowed, use import { ... } from '${MODULE_NAME}'`);
          }
        }
      },

      ImportDeclaration(path, state) {
        var node = path.node;


        if (t.isStringLiteral(node.source, { value: MODULE_NAME })) {
          var specifiers = node.specifiers;

          var specifierCount = specifiers.length;

          // no import 'zent';
          if (specifierCount === 0) {
            throw path.buildCodeFrameError(`Side-effect only import is allowed in ${MODULE_NAME}.'`);
          }

          var replacement = specifiers.reduce(function (r, sp) {
            // no import * as Zent from 'zent'
            if (t.isImportNamespaceSpecifier(sp)) {
              throw path.buildCodeFrameError(`Namespace import is not allowd in ${MODULE_NAME}, pick the components you need.`);
            }

            // no import Zent from 'zent'
            if (t.isImportDefaultSpecifier(sp)) {
              throw path.buildCodeFrameError(`There is no default export in ${MODULE_NAME}.`);
            }

            if (t.isImportSpecifier(sp)) {
              return r.concat(buildImportReplacement(sp, t, state, path));
            }

            throw path.buildCodeFrameError('Unexpected import type');
          }, []);

          var options = state.opts;

          if (options.noModuleRewrite) {
            path.insertAfter(replacement);
          } else {
            path.replaceWithMultiple(replacement);
          }
        }
      }
    }
  };
};

function buildImportReplacement(specifier, types, state, originalPath) {
  initModuleMapppingAsNecessary(state);

  // import {Button as _Button} from 'zent'
  // imported name is Button, but local name is _Button
  var importedName = specifier.imported.name;
  var localName = specifier.local.name;
  var replacement = [];
  var options = state.opts,
      data = state.data;


  if (data.MODULE_MAPPING.hasOwnProperty(importedName)) {
    var rule = data.MODULE_MAPPING[importedName];

    // js
    if (!options.noModuleRewrite) {
      replacement.push(types.importDeclaration([types.importDefaultSpecifier(types.identifier(localName))], types.stringLiteral(rule.js)));
    }

    // style
    if (options.automaticStyleImport) {
      if (options.useRawStyle) {
        if (!rule.postcss) {
          throw originalPath.buildCodeFrameError('`useRawStyle` is not compatible with old versions of zent, please upgrade zent to >= zent@3.8.1');
        }

        rule.postcss.forEach(function (path) {
          if (data.STYLE_IMPORT_MAPPING[path] === undefined) {
            replacement.push(types.importDeclaration([], types.stringLiteral(path)));
            data.STYLE_IMPORT_MAPPING[path] = true;
          }
        });
      } else {
        rule.css.forEach(function (path) {
          if (data.STYLE_IMPORT_MAPPING[path] === undefined) {
            replacement.push(types.importDeclaration([], types.stringLiteral(path)));
            data.STYLE_IMPORT_MAPPING[path] = true;
          }
        });
      }
    }
  }

  return replacement;
}

function initModuleMapppingAsNecessary(state) {
  var options = state.opts;


  if (!state.data) {
    state.data = {};
  }

  var data = state.data;
  if (!data.MODULE_MAPPING) {
    var moduleMappingFile = options.moduleMappingFile || 'zent/lib/module-mapping.json';

    // eslint-disable-next-line
    data.MODULE_MAPPING = require(moduleMappingFile);

    // STYLE_IMPORT_MAPPING 是 css 和 postcss 公用的，因为两者只可能使用一种
    if (options.automaticStyleImport) {
      data.STYLE_IMPORT_MAPPING = {};
    }
  }
}